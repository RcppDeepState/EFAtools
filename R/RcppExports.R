# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Perform the iterative PAF procedure
#'
#' Function called from within PAF so usually no call to this is needed by the user.
#' Provides a C++ implementation of the PAF procedure
#'
#' @param x numeric matrix. The initial communality estimates.
#' @param y numeric matrix. The convergence criterion to use.
#' @param thresh numeric. The threshold to classify a pattern coefficient as substantial.
#' @export
factor_corres <- function(x, y, thresh = 0.3) {
    .Call(`_EFAdiff_factor_corres`, x, y, thresh)
}

#' Perform the iterative PAF procedure
#'
#' Function called from within PAF so usually no call to this is needed by the user.
#' Provides a C++ implementation of the PAF procedure
#'
#' @param n_fac numeric. The number of factors to extract.
#' @param R matrix. The correlation matrix.
#' @param criterion double. The convergence criterion to use.
#' @param max_iter numeric. The number of iterations after which to end the procedure if no convergence has been reached by then.
#' @export
hull_paf <- function(n_fac, R, criterion, max_iter) {
    .Call(`_EFAdiff_hull_paf`, n_fac, R, criterion, max_iter)
}

#' Perform the iterative PAF procedure
#'
#' Function called from within PAF so usually no call to this is needed by the user.
#' Provides a C++ implementation of the PAF procedure
#'
#' @param h2 numeric. The initial communality estimates.
#' @param criterion double. The convergence criterion to use.
#' @param R matrix. The correlation matrix with the initial communality estimates in the diagonal.
#' @param n_fac numeric. The number of factors to extract.
#' @param abs_eig logical. Whether absolute eigenvalues should be used to compute the loadings.
#' @param crit_type numeric. Whether maximum absolute differences (crit_type = 1), or sum of differences (crit_type = 2) should be used
#' @param max_iter numeric. The number of iterations after which to end the procedure if no convergence has been reached by then.
#' @export
paf_iter <- function(h2, criterion, R, n_fac, abs_eig, crit_type, max_iter) {
    .Call(`_EFAdiff_paf_iter`, h2, criterion, R, n_fac, abs_eig, crit_type, max_iter)
}

#' Parallel analysis on simulated data.
#'
#' Function called from within PARALLEL so usually no call to this is needed by the user.
#' Provides a C++ implementation of the PARALLEL simulation procedure
#'
#' @param n_datasets numeric. Number of datasets with dimensions (n_cases, n_vars) to simulate.
#' @param n_vars numeric. Number of variables / indicators in dataset.
#' @param n_cases numeric. Number of cases / observations in dataset.
#' @param eigen_type numeric. Whether PCA (eigen_type = 1; i.e., leaving diagonal of correlation matrix at 1) or PAF (eigen_type = 2; i.e., setting diagonal of correlation matrix to SMCs).
#' @export
parallel_sim <- function(n_datasets, n_vars, n_cases, eigen_type) {
    .Call(`_EFAdiff_parallel_sim`, n_datasets, n_vars, n_cases, eigen_type)
}

#' Principal Axis Factoring to extract eigenvalues from a 1 factor solution
#'
#' Function called from within PARALLEL so usually no call to this is needed by the user.
#' Provides a C++ implementation of 1 factor PAF. Returns the eigenvalues obtained
#' from the correlation matrix with the final communality estimates as diagonal of
#' R.
#'
#' @param R numeric matrix. Correlation matrix to perform PAF with 1 factor solution on.
#' @param criterion double. Convergence criterion to use.
#' @param crit_type integer. Whether max_individual (1) or sums (2).
#' @param max_iter integer. The maximum number of iterations after which to stop the iterative procedure if no convergence is reached by then.
#' @export
parallel_paf <- function(R, criterion, crit_type, max_iter) {
    .Call(`_EFAdiff_parallel_paf`, R, criterion, crit_type, max_iter)
}

#' Parallel analysis on simulated data.
#'
#' Function called from within PARALLEL so usually no call to this is needed by the user.
#' Provides a C++ implementation of the PARALLEL simulation procedure where eigenvalues
#' are found using the parallel_paf function.
#'
#' @param n_datasets numeric. Number of datasets with dimensions (n_cases, n_vars) to simulate.
#' @param n_vars numeric. Number of variables / indicators in dataset.
#' @param n_cases numeric. Number of cases / observations in dataset.
#' @param criterion double. Convergence criterion to use.
#' @param crit_type integer. Whether max_individual (1) or sums (2).
#' @param max_iter integer. The maximum number of iterations after which to stop the iterative procedure if no convergence is reached by then.
#' @export
parallel_paf_sim <- function(n_datasets, n_vars, n_cases, criterion, crit_type, max_iter) {
    .Call(`_EFAdiff_parallel_paf_sim`, n_datasets, n_vars, n_cases, criterion, crit_type, max_iter)
}

#' Summarise the raw data from the \link{parallel_sim}
#'
#' Function called from within PARALLEL so usually no call to this is needed by the user.
#' Provides a C++ implementation to aggregate the eigenvalues from the simulations
#' performed using \link{parallel_sim}.
#'
#' @param eig_vals matrix. A matrix as returned by \link{parallel_sim}.
#' @param percent numeric. A vector of percentiles for which the eigenvalues should be returned.
#' @param n_datasets integer. The number of datasets simulated in \link{parallel_sim}.
#' @param n_vars numeric. The number of variables / indicators per dataset.
#' @export
parallel_summarise <- function(eig_vals, percent, n_datasets, n_vars) {
    .Call(`_EFAdiff_parallel_summarise`, eig_vals, percent, n_datasets, n_vars)
}

.grad_uls <- function(psi, R, n_fac) {
    .Call(`_EFAdiff_grad_uls`, psi, R, n_fac)
}

.uls_residuals <- function(psi, R, n_fac) {
    .Call(`_EFAdiff_uls_residuals`, psi, R, n_fac)
}

